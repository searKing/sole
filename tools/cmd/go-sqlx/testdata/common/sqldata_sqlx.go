// Code generated by "go-sqlx -type SqlData --with-dao --with-query-info"; DO NOT EDIT.

package main

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"reflect"
	"strings"

	"github.com/jmoiron/sqlx"
	sql_ "github.com/searKing/golang/go/database/sql"
	reflect_ "github.com/searKing/golang/go/reflect"
	sqlx_ "github.com/searKing/golang/third_party/github.com/jmoiron/sqlx"
)

// SqlData represents an orm of table sql_data.
// SqlData implements the Scanner interface so
// it can be used as a scan destination, similar to sql.NullString.

// TableName returns table's name
func (_ SqlData) TableName() string {
	return "sql_data"
}

func (m SqlData) TableColumn(col string) string {
	return fmt.Sprintf("%s.%s", m.TableName(), col)
}

// CompliantTableColumn returns a compliant TableColumn name
// replace special runes with '_'
// a.b -> a_b
func (m SqlData) CompliantTableColumn(col string) string {
	return sql_.CompliantName(m.TableColumn(col))
}

func (m SqlData) MapColumn(col string) string {
	return m.CompliantTableColumn(col)
	//return fmt.Sprintf("%s_%s", m.TableName(), col)
}

func (m SqlData) Columns() []string {
	var cols []string
	cols = append(cols, m.ColumnId())
	cols = append(cols, m.ColumnCreatedAt())
	cols = append(cols, m.ColumnUpdatedAt())
	cols = append(cols, m.ColumnIsDeleted())
	cols = append(cols, m.ColumnDeletedAt())
	cols = append(cols, m.ColumnVersion())
	return cols
}

func (m SqlData) NonzeroColumns() []string {
	var cols []string
	{
		if !m.IsIdZero() {
			cols = append(cols, m.ColumnId())
		}
	}
	{
		if !m.IsCreatedAtZero() {
			cols = append(cols, m.ColumnCreatedAt())
		}
	}
	{
		if !m.IsUpdatedAtZero() {
			cols = append(cols, m.ColumnUpdatedAt())
		}
	}
	{
		if !m.IsIsDeletedZero() {
			cols = append(cols, m.ColumnIsDeleted())
		}
	}
	{
		if !m.IsDeletedAtZero() {
			cols = append(cols, m.ColumnDeletedAt())
		}
	}
	{
		if !m.IsVersionZero() {
			cols = append(cols, m.ColumnVersion())
		}
	}
	return cols
}

func (m SqlData) NonzeroColumnsIn(cols ...string) []string {
	var nonzeroCols []string
	for _, col := range cols {
		switch col {
		case m.ColumnId():
			if !m.IsIdZero() {
				cols = append(cols, m.ColumnId())
			}
		case m.ColumnCreatedAt():
			if !m.IsCreatedAtZero() {
				cols = append(cols, m.ColumnCreatedAt())
			}
		case m.ColumnUpdatedAt():
			if !m.IsUpdatedAtZero() {
				cols = append(cols, m.ColumnUpdatedAt())
			}
		case m.ColumnIsDeleted():
			if !m.IsIsDeletedZero() {
				cols = append(cols, m.ColumnIsDeleted())
			}
		case m.ColumnDeletedAt():
			if !m.IsDeletedAtZero() {
				cols = append(cols, m.ColumnDeletedAt())
			}
		case m.ColumnVersion():
			if !m.IsVersionZero() {
				cols = append(cols, m.ColumnVersion())
			}
		default:
		}
	}
	return nonzeroCols
}

func (m SqlData) NonzeroTableColumns() []string {
	var cols []string
	{
		if !m.IsIdZero() {
			cols = append(cols, m.TableColumnId())
		}
	}
	{
		if !m.IsCreatedAtZero() {
			cols = append(cols, m.TableColumnCreatedAt())
		}
	}
	{
		if !m.IsUpdatedAtZero() {
			cols = append(cols, m.TableColumnUpdatedAt())
		}
	}
	{
		if !m.IsIsDeletedZero() {
			cols = append(cols, m.TableColumnIsDeleted())
		}
	}
	{
		if !m.IsDeletedAtZero() {
			cols = append(cols, m.TableColumnDeletedAt())
		}
	}
	{
		if !m.IsVersionZero() {
			cols = append(cols, m.TableColumnVersion())
		}
	}
	return cols
}

func (m SqlData) NonzeroTableColumnsIn(cols ...string) []string {
	var nonzeroCols []string
	for _, col := range cols {
		switch col {
		case m.ColumnId():
			if !m.IsIdZero() {
				cols = append(cols, m.TableColumnId())
			}
		case m.ColumnCreatedAt():
			if !m.IsCreatedAtZero() {
				cols = append(cols, m.TableColumnCreatedAt())
			}
		case m.ColumnUpdatedAt():
			if !m.IsUpdatedAtZero() {
				cols = append(cols, m.TableColumnUpdatedAt())
			}
		case m.ColumnIsDeleted():
			if !m.IsIsDeletedZero() {
				cols = append(cols, m.TableColumnIsDeleted())
			}
		case m.ColumnDeletedAt():
			if !m.IsDeletedAtZero() {
				cols = append(cols, m.TableColumnDeletedAt())
			}
		case m.ColumnVersion():
			if !m.IsVersionZero() {
				cols = append(cols, m.TableColumnVersion())
			}
		default:
		}
	}
	return nonzeroCols
}

// MarshalMap marshal themselves into or append a valid map
// key is column name in db, from struct tag db:"xxxx"
func (m SqlData) MarshalMap(valueByCol map[string]interface{}) map[string]interface{} {
	if valueByCol == nil {
		valueByCol = map[string]interface{}{}
	}
	valueByCol[m.ColumnId()] = m.Id
	valueByCol[m.ColumnCreatedAt()] = m.CreatedAt
	valueByCol[m.ColumnUpdatedAt()] = m.UpdatedAt
	valueByCol[m.ColumnIsDeleted()] = m.IsDeleted
	valueByCol[m.ColumnDeletedAt()] = m.DeletedAt
	valueByCol[m.ColumnVersion()] = m.Version
	return valueByCol
}

// MarshalTableMap marshal themselves into or append a valid map
// key is column name in db with table name, from struct tag db:"xxxx"
func (m SqlData) MarshalTableMap(valueByCol map[string]interface{}) map[string]interface{} {
	if valueByCol == nil {
		valueByCol = map[string]interface{}{}
	}
	valueByCol[m.TableColumnId()] = m.Id
	valueByCol[m.TableColumnCreatedAt()] = m.CreatedAt
	valueByCol[m.TableColumnUpdatedAt()] = m.UpdatedAt
	valueByCol[m.TableColumnIsDeleted()] = m.IsDeleted
	valueByCol[m.TableColumnDeletedAt()] = m.DeletedAt
	valueByCol[m.TableColumnVersion()] = m.Version
	return valueByCol
}

// UnmarshalMap is the interface implemented by types
// that can unmarshal a map description of themselves.
// key is column name in db, from struct tag db:"xxxx"
func (m *SqlData) UnmarshalMap(valueByCol map[string]interface{}) error {
	for col, val := range valueByCol {
		switch col {
		case m.ColumnId():
			// for sql.Scanner
			v := reflect.ValueOf(&m.Id)
			if v.Type().NumMethod() > 0 && v.CanInterface() {
				if u, ok := v.Interface().(sql.Scanner); ok {
					if err := u.Scan(val); err != nil {
						return fmt.Errorf("unmarshal col %q, got %w", col, err)
					}
					break
				}
			}

			data, err := json.Marshal(val)
			if err != nil {
				return fmt.Errorf("marshal col %q, got %w", col, err)
			}
			err = json.Unmarshal(data, &m.Id)
			if err != nil {
				return fmt.Errorf("unmarshal col %q, got %w", col, err)
			}
		case m.ColumnCreatedAt():
			// for sql.Scanner
			v := reflect.ValueOf(&m.CreatedAt)
			if v.Type().NumMethod() > 0 && v.CanInterface() {
				if u, ok := v.Interface().(sql.Scanner); ok {
					if err := u.Scan(val); err != nil {
						return fmt.Errorf("unmarshal col %q, got %w", col, err)
					}
					break
				}
			}

			data, err := json.Marshal(val)
			if err != nil {
				return fmt.Errorf("marshal col %q, got %w", col, err)
			}
			err = json.Unmarshal(data, &m.CreatedAt)
			if err != nil {
				return fmt.Errorf("unmarshal col %q, got %w", col, err)
			}
		case m.ColumnUpdatedAt():
			// for sql.Scanner
			v := reflect.ValueOf(&m.UpdatedAt)
			if v.Type().NumMethod() > 0 && v.CanInterface() {
				if u, ok := v.Interface().(sql.Scanner); ok {
					if err := u.Scan(val); err != nil {
						return fmt.Errorf("unmarshal col %q, got %w", col, err)
					}
					break
				}
			}

			data, err := json.Marshal(val)
			if err != nil {
				return fmt.Errorf("marshal col %q, got %w", col, err)
			}
			err = json.Unmarshal(data, &m.UpdatedAt)
			if err != nil {
				return fmt.Errorf("unmarshal col %q, got %w", col, err)
			}
		case m.ColumnIsDeleted():
			// for sql.Scanner
			v := reflect.ValueOf(&m.IsDeleted)
			if v.Type().NumMethod() > 0 && v.CanInterface() {
				if u, ok := v.Interface().(sql.Scanner); ok {
					if err := u.Scan(val); err != nil {
						return fmt.Errorf("unmarshal col %q, got %w", col, err)
					}
					break
				}
			}

			data, err := json.Marshal(val)
			if err != nil {
				return fmt.Errorf("marshal col %q, got %w", col, err)
			}
			err = json.Unmarshal(data, &m.IsDeleted)
			if err != nil {
				return fmt.Errorf("unmarshal col %q, got %w", col, err)
			}
		case m.ColumnDeletedAt():
			// for sql.Scanner
			v := reflect.ValueOf(&m.DeletedAt)
			if v.Type().NumMethod() > 0 && v.CanInterface() {
				if u, ok := v.Interface().(sql.Scanner); ok {
					if err := u.Scan(val); err != nil {
						return fmt.Errorf("unmarshal col %q, got %w", col, err)
					}
					break
				}
			}

			data, err := json.Marshal(val)
			if err != nil {
				return fmt.Errorf("marshal col %q, got %w", col, err)
			}
			err = json.Unmarshal(data, &m.DeletedAt)
			if err != nil {
				return fmt.Errorf("unmarshal col %q, got %w", col, err)
			}
		case m.ColumnVersion():
			// for sql.Scanner
			v := reflect.ValueOf(&m.Version)
			if v.Type().NumMethod() > 0 && v.CanInterface() {
				if u, ok := v.Interface().(sql.Scanner); ok {
					if err := u.Scan(val); err != nil {
						return fmt.Errorf("unmarshal col %q, got %w", col, err)
					}
					break
				}
			}

			data, err := json.Marshal(val)
			if err != nil {
				return fmt.Errorf("marshal col %q, got %w", col, err)
			}
			err = json.Unmarshal(data, &m.Version)
			if err != nil {
				return fmt.Errorf("unmarshal col %q, got %w", col, err)
			}
		}
	}
	return nil
}

// UnmarshalTableMap is the interface implemented by types
// that can unmarshal a map description of themselves.
// key is column name with table name in db, from struct tag db:"xxxx"
func (m *SqlData) UnmarshalTableMap(valueByCol map[string]interface{}) error {
	for col, val := range valueByCol {
		switch col {
		case m.MapColumnId():
			// for sql.Scanner
			v := reflect.ValueOf(&m.Id)
			if v.Type().NumMethod() > 0 && v.CanInterface() {
				if u, ok := v.Interface().(sql.Scanner); ok {
					if err := u.Scan(val); err != nil {
						return fmt.Errorf("unmarshal col %q, got %w", col, err)
					}
					break
				}
			}

			data, err := json.Marshal(val)
			if err != nil {
				return fmt.Errorf("marshal col %q, got %w", col, err)
			}
			err = json.Unmarshal(data, &m.Id)
			if err != nil {
				return fmt.Errorf("unmarshal col %q, got %w", col, err)
			}
		case m.MapColumnCreatedAt():
			// for sql.Scanner
			v := reflect.ValueOf(&m.CreatedAt)
			if v.Type().NumMethod() > 0 && v.CanInterface() {
				if u, ok := v.Interface().(sql.Scanner); ok {
					if err := u.Scan(val); err != nil {
						return fmt.Errorf("unmarshal col %q, got %w", col, err)
					}
					break
				}
			}

			data, err := json.Marshal(val)
			if err != nil {
				return fmt.Errorf("marshal col %q, got %w", col, err)
			}
			err = json.Unmarshal(data, &m.CreatedAt)
			if err != nil {
				return fmt.Errorf("unmarshal col %q, got %w", col, err)
			}
		case m.MapColumnUpdatedAt():
			// for sql.Scanner
			v := reflect.ValueOf(&m.UpdatedAt)
			if v.Type().NumMethod() > 0 && v.CanInterface() {
				if u, ok := v.Interface().(sql.Scanner); ok {
					if err := u.Scan(val); err != nil {
						return fmt.Errorf("unmarshal col %q, got %w", col, err)
					}
					break
				}
			}

			data, err := json.Marshal(val)
			if err != nil {
				return fmt.Errorf("marshal col %q, got %w", col, err)
			}
			err = json.Unmarshal(data, &m.UpdatedAt)
			if err != nil {
				return fmt.Errorf("unmarshal col %q, got %w", col, err)
			}
		case m.MapColumnIsDeleted():
			// for sql.Scanner
			v := reflect.ValueOf(&m.IsDeleted)
			if v.Type().NumMethod() > 0 && v.CanInterface() {
				if u, ok := v.Interface().(sql.Scanner); ok {
					if err := u.Scan(val); err != nil {
						return fmt.Errorf("unmarshal col %q, got %w", col, err)
					}
					break
				}
			}

			data, err := json.Marshal(val)
			if err != nil {
				return fmt.Errorf("marshal col %q, got %w", col, err)
			}
			err = json.Unmarshal(data, &m.IsDeleted)
			if err != nil {
				return fmt.Errorf("unmarshal col %q, got %w", col, err)
			}
		case m.MapColumnDeletedAt():
			// for sql.Scanner
			v := reflect.ValueOf(&m.DeletedAt)
			if v.Type().NumMethod() > 0 && v.CanInterface() {
				if u, ok := v.Interface().(sql.Scanner); ok {
					if err := u.Scan(val); err != nil {
						return fmt.Errorf("unmarshal col %q, got %w", col, err)
					}
					break
				}
			}

			data, err := json.Marshal(val)
			if err != nil {
				return fmt.Errorf("marshal col %q, got %w", col, err)
			}
			err = json.Unmarshal(data, &m.DeletedAt)
			if err != nil {
				return fmt.Errorf("unmarshal col %q, got %w", col, err)
			}
		case m.MapColumnVersion():
			// for sql.Scanner
			v := reflect.ValueOf(&m.Version)
			if v.Type().NumMethod() > 0 && v.CanInterface() {
				if u, ok := v.Interface().(sql.Scanner); ok {
					if err := u.Scan(val); err != nil {
						return fmt.Errorf("unmarshal col %q, got %w", col, err)
					}
					break
				}
			}

			data, err := json.Marshal(val)
			if err != nil {
				return fmt.Errorf("marshal col %q, got %w", col, err)
			}
			err = json.Unmarshal(data, &m.Version)
			if err != nil {
				return fmt.Errorf("unmarshal col %q, got %w", col, err)
			}
		}
	}
	return nil
}

// ColumnId return column name in db, from struct tag db:"id"
func (_ SqlData) ColumnId() string {
	return "id"
}

// TableColumnId return column name with TableName
// "sql_data.id"
func (_ SqlData) TableColumnId() string {
	// avoid runtime cost of fmt.Sprintf
	// return fmt.Sprintf("%s.%s", a.TableName(), a.ColumnSqlData())
	return "sql_data.id"
}

// TableColumnIdWithAs return column name with TableName
// "sql_data.id AS sql_data_id"
func (m SqlData) TableColumnIdWithAs() string {
	return fmt.Sprintf("%s AS %s", m.TableColumnId(), m.MapColumnId())
}

// MapColumnSqlData return column name with TableName
// "sql_data_id"
func (m SqlData) MapColumnId() string {
	// avoid runtime cost of fmt.Sprintf
	// return fmt.Sprintf("%s_%s", m.TableName(), m.ColumnSqlData())
	// return "sql_data_id"
	return sql_.CompliantName(m.TableColumnId())
}

// NonZero

// IsIdZero return Id is zero or not
func (m SqlData) IsIdZero() bool {
	return reflect_.IsZeroValue(reflect.ValueOf(m.Id))
}

// NonzeroColumnId return column name in db, from struct tag db:"id"
// return empty string if field is zero value
func (m SqlData) NonzeroColumnId() string {
	if m.IsIdZero() {
		return ""
	}
	return m.ColumnId()
}

// TableColumnId return column name with TableName
// return empty string if field is zero value
// "sql_data.id"
func (m SqlData) NonzeroTableColumnId() string {
	if m.IsIdZero() {
		return ""
	}
	// avoid runtime cost of fmt.Sprintf
	// return fmt.Sprintf("%s.%s", a.TableName(), a.ColumnSqlData())
	return m.TableColumnId()
}

// TableColumnIdWithAs return column name with TableName
// return empty string if field is zero value
// "sql_data.id AS sql_data_id"
func (m SqlData) NonzeroTableColumnIdWithAs() string {
	if m.IsIdZero() {
		return ""
	}
	return m.TableColumnIdWithAs()
}

// MapColumnSqlData return column name with TableName
// "sql_data_id"
func (m SqlData) NonzeroMapColumnId() string {
	if m.IsIdZero() {
		return ""
	}
	return m.MapColumnId()
}

// ColumnCreatedAt return column name in db, from struct tag db:"created_at"
func (_ SqlData) ColumnCreatedAt() string {
	return "created_at"
}

// TableColumnCreatedAt return column name with TableName
// "sql_data.created_at"
func (_ SqlData) TableColumnCreatedAt() string {
	// avoid runtime cost of fmt.Sprintf
	// return fmt.Sprintf("%s.%s", a.TableName(), a.ColumnSqlData())
	return "sql_data.created_at"
}

// TableColumnCreatedAtWithAs return column name with TableName
// "sql_data.created_at AS sql_data_created_at"
func (m SqlData) TableColumnCreatedAtWithAs() string {
	return fmt.Sprintf("%s AS %s", m.TableColumnCreatedAt(), m.MapColumnCreatedAt())
}

// MapColumnSqlData return column name with TableName
// "sql_data_created_at"
func (m SqlData) MapColumnCreatedAt() string {
	// avoid runtime cost of fmt.Sprintf
	// return fmt.Sprintf("%s_%s", m.TableName(), m.ColumnSqlData())
	// return "sql_data_created_at"
	return sql_.CompliantName(m.TableColumnCreatedAt())
}

// NonZero

// IsCreatedAtZero return CreatedAt is zero or not
func (m SqlData) IsCreatedAtZero() bool {
	return reflect_.IsZeroValue(reflect.ValueOf(m.CreatedAt))
}

// NonzeroColumnCreatedAt return column name in db, from struct tag db:"created_at"
// return empty string if field is zero value
func (m SqlData) NonzeroColumnCreatedAt() string {
	if m.IsCreatedAtZero() {
		return ""
	}
	return m.ColumnCreatedAt()
}

// TableColumnCreatedAt return column name with TableName
// return empty string if field is zero value
// "sql_data.created_at"
func (m SqlData) NonzeroTableColumnCreatedAt() string {
	if m.IsCreatedAtZero() {
		return ""
	}
	// avoid runtime cost of fmt.Sprintf
	// return fmt.Sprintf("%s.%s", a.TableName(), a.ColumnSqlData())
	return m.TableColumnCreatedAt()
}

// TableColumnCreatedAtWithAs return column name with TableName
// return empty string if field is zero value
// "sql_data.created_at AS sql_data_created_at"
func (m SqlData) NonzeroTableColumnCreatedAtWithAs() string {
	if m.IsCreatedAtZero() {
		return ""
	}
	return m.TableColumnCreatedAtWithAs()
}

// MapColumnSqlData return column name with TableName
// "sql_data_created_at"
func (m SqlData) NonzeroMapColumnCreatedAt() string {
	if m.IsCreatedAtZero() {
		return ""
	}
	return m.MapColumnCreatedAt()
}

// ColumnUpdatedAt return column name in db, from struct tag db:"updated_at"
func (_ SqlData) ColumnUpdatedAt() string {
	return "updated_at"
}

// TableColumnUpdatedAt return column name with TableName
// "sql_data.updated_at"
func (_ SqlData) TableColumnUpdatedAt() string {
	// avoid runtime cost of fmt.Sprintf
	// return fmt.Sprintf("%s.%s", a.TableName(), a.ColumnSqlData())
	return "sql_data.updated_at"
}

// TableColumnUpdatedAtWithAs return column name with TableName
// "sql_data.updated_at AS sql_data_updated_at"
func (m SqlData) TableColumnUpdatedAtWithAs() string {
	return fmt.Sprintf("%s AS %s", m.TableColumnUpdatedAt(), m.MapColumnUpdatedAt())
}

// MapColumnSqlData return column name with TableName
// "sql_data_updated_at"
func (m SqlData) MapColumnUpdatedAt() string {
	// avoid runtime cost of fmt.Sprintf
	// return fmt.Sprintf("%s_%s", m.TableName(), m.ColumnSqlData())
	// return "sql_data_updated_at"
	return sql_.CompliantName(m.TableColumnUpdatedAt())
}

// NonZero

// IsUpdatedAtZero return UpdatedAt is zero or not
func (m SqlData) IsUpdatedAtZero() bool {
	return reflect_.IsZeroValue(reflect.ValueOf(m.UpdatedAt))
}

// NonzeroColumnUpdatedAt return column name in db, from struct tag db:"updated_at"
// return empty string if field is zero value
func (m SqlData) NonzeroColumnUpdatedAt() string {
	if m.IsUpdatedAtZero() {
		return ""
	}
	return m.ColumnUpdatedAt()
}

// TableColumnUpdatedAt return column name with TableName
// return empty string if field is zero value
// "sql_data.updated_at"
func (m SqlData) NonzeroTableColumnUpdatedAt() string {
	if m.IsUpdatedAtZero() {
		return ""
	}
	// avoid runtime cost of fmt.Sprintf
	// return fmt.Sprintf("%s.%s", a.TableName(), a.ColumnSqlData())
	return m.TableColumnUpdatedAt()
}

// TableColumnUpdatedAtWithAs return column name with TableName
// return empty string if field is zero value
// "sql_data.updated_at AS sql_data_updated_at"
func (m SqlData) NonzeroTableColumnUpdatedAtWithAs() string {
	if m.IsUpdatedAtZero() {
		return ""
	}
	return m.TableColumnUpdatedAtWithAs()
}

// MapColumnSqlData return column name with TableName
// "sql_data_updated_at"
func (m SqlData) NonzeroMapColumnUpdatedAt() string {
	if m.IsUpdatedAtZero() {
		return ""
	}
	return m.MapColumnUpdatedAt()
}

// ColumnIsDeleted return column name in db, from struct tag db:"is_deleted"
func (_ SqlData) ColumnIsDeleted() string {
	return "is_deleted"
}

// TableColumnIsDeleted return column name with TableName
// "sql_data.is_deleted"
func (_ SqlData) TableColumnIsDeleted() string {
	// avoid runtime cost of fmt.Sprintf
	// return fmt.Sprintf("%s.%s", a.TableName(), a.ColumnSqlData())
	return "sql_data.is_deleted"
}

// TableColumnIsDeletedWithAs return column name with TableName
// "sql_data.is_deleted AS sql_data_is_deleted"
func (m SqlData) TableColumnIsDeletedWithAs() string {
	return fmt.Sprintf("%s AS %s", m.TableColumnIsDeleted(), m.MapColumnIsDeleted())
}

// MapColumnSqlData return column name with TableName
// "sql_data_is_deleted"
func (m SqlData) MapColumnIsDeleted() string {
	// avoid runtime cost of fmt.Sprintf
	// return fmt.Sprintf("%s_%s", m.TableName(), m.ColumnSqlData())
	// return "sql_data_is_deleted"
	return sql_.CompliantName(m.TableColumnIsDeleted())
}

// NonZero

// IsIsDeletedZero return IsDeleted is zero or not
func (m SqlData) IsIsDeletedZero() bool {
	return reflect_.IsZeroValue(reflect.ValueOf(m.IsDeleted))
}

// NonzeroColumnIsDeleted return column name in db, from struct tag db:"is_deleted"
// return empty string if field is zero value
func (m SqlData) NonzeroColumnIsDeleted() string {
	if m.IsIsDeletedZero() {
		return ""
	}
	return m.ColumnIsDeleted()
}

// TableColumnIsDeleted return column name with TableName
// return empty string if field is zero value
// "sql_data.is_deleted"
func (m SqlData) NonzeroTableColumnIsDeleted() string {
	if m.IsIsDeletedZero() {
		return ""
	}
	// avoid runtime cost of fmt.Sprintf
	// return fmt.Sprintf("%s.%s", a.TableName(), a.ColumnSqlData())
	return m.TableColumnIsDeleted()
}

// TableColumnIsDeletedWithAs return column name with TableName
// return empty string if field is zero value
// "sql_data.is_deleted AS sql_data_is_deleted"
func (m SqlData) NonzeroTableColumnIsDeletedWithAs() string {
	if m.IsIsDeletedZero() {
		return ""
	}
	return m.TableColumnIsDeletedWithAs()
}

// MapColumnSqlData return column name with TableName
// "sql_data_is_deleted"
func (m SqlData) NonzeroMapColumnIsDeleted() string {
	if m.IsIsDeletedZero() {
		return ""
	}
	return m.MapColumnIsDeleted()
}

// ColumnDeletedAt return column name in db, from struct tag db:"deleted_at"
func (_ SqlData) ColumnDeletedAt() string {
	return "deleted_at"
}

// TableColumnDeletedAt return column name with TableName
// "sql_data.deleted_at"
func (_ SqlData) TableColumnDeletedAt() string {
	// avoid runtime cost of fmt.Sprintf
	// return fmt.Sprintf("%s.%s", a.TableName(), a.ColumnSqlData())
	return "sql_data.deleted_at"
}

// TableColumnDeletedAtWithAs return column name with TableName
// "sql_data.deleted_at AS sql_data_deleted_at"
func (m SqlData) TableColumnDeletedAtWithAs() string {
	return fmt.Sprintf("%s AS %s", m.TableColumnDeletedAt(), m.MapColumnDeletedAt())
}

// MapColumnSqlData return column name with TableName
// "sql_data_deleted_at"
func (m SqlData) MapColumnDeletedAt() string {
	// avoid runtime cost of fmt.Sprintf
	// return fmt.Sprintf("%s_%s", m.TableName(), m.ColumnSqlData())
	// return "sql_data_deleted_at"
	return sql_.CompliantName(m.TableColumnDeletedAt())
}

// NonZero

// IsDeletedAtZero return DeletedAt is zero or not
func (m SqlData) IsDeletedAtZero() bool {
	return reflect_.IsZeroValue(reflect.ValueOf(m.DeletedAt))
}

// NonzeroColumnDeletedAt return column name in db, from struct tag db:"deleted_at"
// return empty string if field is zero value
func (m SqlData) NonzeroColumnDeletedAt() string {
	if m.IsDeletedAtZero() {
		return ""
	}
	return m.ColumnDeletedAt()
}

// TableColumnDeletedAt return column name with TableName
// return empty string if field is zero value
// "sql_data.deleted_at"
func (m SqlData) NonzeroTableColumnDeletedAt() string {
	if m.IsDeletedAtZero() {
		return ""
	}
	// avoid runtime cost of fmt.Sprintf
	// return fmt.Sprintf("%s.%s", a.TableName(), a.ColumnSqlData())
	return m.TableColumnDeletedAt()
}

// TableColumnDeletedAtWithAs return column name with TableName
// return empty string if field is zero value
// "sql_data.deleted_at AS sql_data_deleted_at"
func (m SqlData) NonzeroTableColumnDeletedAtWithAs() string {
	if m.IsDeletedAtZero() {
		return ""
	}
	return m.TableColumnDeletedAtWithAs()
}

// MapColumnSqlData return column name with TableName
// "sql_data_deleted_at"
func (m SqlData) NonzeroMapColumnDeletedAt() string {
	if m.IsDeletedAtZero() {
		return ""
	}
	return m.MapColumnDeletedAt()
}

// ColumnVersion return column name in db, from struct tag db:"version"
func (_ SqlData) ColumnVersion() string {
	return "version"
}

// TableColumnVersion return column name with TableName
// "sql_data.version"
func (_ SqlData) TableColumnVersion() string {
	// avoid runtime cost of fmt.Sprintf
	// return fmt.Sprintf("%s.%s", a.TableName(), a.ColumnSqlData())
	return "sql_data.version"
}

// TableColumnVersionWithAs return column name with TableName
// "sql_data.version AS sql_data_version"
func (m SqlData) TableColumnVersionWithAs() string {
	return fmt.Sprintf("%s AS %s", m.TableColumnVersion(), m.MapColumnVersion())
}

// MapColumnSqlData return column name with TableName
// "sql_data_version"
func (m SqlData) MapColumnVersion() string {
	// avoid runtime cost of fmt.Sprintf
	// return fmt.Sprintf("%s_%s", m.TableName(), m.ColumnSqlData())
	// return "sql_data_version"
	return sql_.CompliantName(m.TableColumnVersion())
}

// NonZero

// IsVersionZero return Version is zero or not
func (m SqlData) IsVersionZero() bool {
	return reflect_.IsZeroValue(reflect.ValueOf(m.Version))
}

// NonzeroColumnVersion return column name in db, from struct tag db:"version"
// return empty string if field is zero value
func (m SqlData) NonzeroColumnVersion() string {
	if m.IsVersionZero() {
		return ""
	}
	return m.ColumnVersion()
}

// TableColumnVersion return column name with TableName
// return empty string if field is zero value
// "sql_data.version"
func (m SqlData) NonzeroTableColumnVersion() string {
	if m.IsVersionZero() {
		return ""
	}
	// avoid runtime cost of fmt.Sprintf
	// return fmt.Sprintf("%s.%s", a.TableName(), a.ColumnSqlData())
	return m.TableColumnVersion()
}

// TableColumnVersionWithAs return column name with TableName
// return empty string if field is zero value
// "sql_data.version AS sql_data_version"
func (m SqlData) NonzeroTableColumnVersionWithAs() string {
	if m.IsVersionZero() {
		return ""
	}
	return m.TableColumnVersionWithAs()
}

// MapColumnSqlData return column name with TableName
// "sql_data_version"
func (m SqlData) NonzeroMapColumnVersion() string {
	if m.IsVersionZero() {
		return ""
	}
	return m.MapColumnVersion()
}

// DAO

func (arg SqlData) AddSqlData(ctx context.Context, db *sqlx.DB, update bool) error {
	query := sqlx_.SimpleStatements{
		TableName: arg.TableName(),
		Columns:   arg.NonzeroColumns(),
	}.NamedInsertStatement(update)

	_, err := db.NamedExecContext(ctx, query, arg)
	if err != nil {
		return fmt.Errorf("%w, sql %q", err, query)
	}
	return nil
}

func (arg SqlData) AddSqlDataWithTx(ctx context.Context, tx *sqlx.Tx, update bool) error {
	query := sqlx_.SimpleStatements{
		TableName: arg.TableName(),
		Columns:   arg.NonzeroColumns(),
	}.NamedInsertStatement(update)

	_, err := tx.NamedExecContext(ctx, query, arg)
	if err != nil {
		return fmt.Errorf("%w, sql %q", err, query)
	}
	return nil
}

func (arg SqlData) DeleteSqlData(ctx context.Context, db *sqlx.DB, conds []string) error {
	query := sqlx_.SimpleStatements{
		TableName:  arg.TableName(),
		Conditions: conds, // WHERE 条件
	}.NamedDeleteStatement()

	_, err := db.NamedExecContext(ctx, query, arg)
	if err != nil {
		return fmt.Errorf("%w, sql %q", err, query)
	}
	return nil
}

func (arg SqlData) DeleteSqlDataWithTx(ctx context.Context, tx *sqlx.Tx, conds []string) error {
	query := sqlx_.SimpleStatements{
		TableName:  arg.TableName(),
		Conditions: conds, // WHERE 条件
	}.NamedDeleteStatement()

	_, err := tx.NamedExecContext(ctx, query, arg)
	if err != nil {
		return fmt.Errorf("%w, sql %q", err, query)
	}
	return nil
}

func (arg SqlData) UpdateSqlData(ctx context.Context, db *sqlx.DB, cols []string, conds []string, insert bool) error {
	query := sqlx_.SimpleStatements{
		TableName:  arg.TableName(),
		Columns:    cols,  // 要查询或修改的列名
		Conditions: conds, // WHERE 条件
	}.NamedUpdateStatement(insert)

	_, err := db.NamedExecContext(ctx, query, arg)
	if err != nil {
		return fmt.Errorf("%w, sql %q", err, query)
	}

	return nil
}

func (arg SqlData) UpdateSqlDataWithTx(ctx context.Context, tx *sqlx.Tx, cols []string, conds []string, insert bool) error {
	query := sqlx_.SimpleStatements{
		TableName:  arg.TableName(),
		Columns:    cols,  // 要查询或修改的列名
		Conditions: conds, // WHERE 条件
	}.NamedUpdateStatement(insert)

	_, err := tx.NamedExecContext(ctx, query, arg)
	if err != nil {
		return fmt.Errorf("%w, sql %q", err, query)
	}

	return nil
}

func (arg SqlData) GetSqlData(ctx context.Context, db *sqlx.DB, cols []string, conds []string) (SqlData, error) {
	query := sqlx_.SimpleStatements{
		TableName:  arg.TableName(),
		Columns:    cols,
		Conditions: conds,
	}.NamedSelectStatement()

	// Check that invalid preparations fail
	ns, err := db.PrepareNamedContext(ctx, query)
	if err != nil {
		return SqlData{}, fmt.Errorf("%w, sql %q", err, query)
	}

	defer ns.Close()

	var dest SqlData
	err = ns.GetContext(ctx, &dest, arg)
	if err != nil {
		//if errors.Cause(err) == sql.ErrNoRows {
		//	return dest, nil
		//}
		return SqlData{}, fmt.Errorf("%w, sql %q", err, query)
	}
	return dest, nil
}

func (arg SqlData) GetSqlDatasByQuery(ctx context.Context, db *sqlx.DB, query string) ([]SqlData, error) {
	// Check that invalid preparations fail
	ns, err := db.PrepareNamedContext(ctx, query)
	if err != nil {
		return nil, fmt.Errorf("%w, sql %q", err, query)
	}

	defer ns.Close()

	var dest []SqlData
	err = ns.SelectContext(ctx, &dest, arg)
	if err != nil {
		return nil, fmt.Errorf("%w, sql %q", err, query)
	}
	return dest, nil
}

func (arg SqlData) GetSqlDatasWithTxByQuery(ctx context.Context, tx *sqlx.Tx, query string) ([]SqlData, error) {
	// Check that invalid preparations fail
	ns, err := tx.PrepareNamedContext(ctx, query)
	if err != nil {
		return nil, fmt.Errorf("%w, sql %q", err, query)
	}

	defer ns.Close()

	var dest []SqlData
	err = ns.SelectContext(ctx, &dest, arg)
	if err != nil {
		return nil, fmt.Errorf("%w, sql %q", err, query)
	}
	return dest, nil
}

func (arg SqlData) GetSqlDatas(ctx context.Context, db *sqlx.DB, cols []string, conds []string, likeConds []string, orderByCols []string) ([]SqlData, error) {
	query := sqlx_.SimpleStatements{
		TableName:  arg.TableName(),
		Columns:    cols,
		Conditions: conds,
		Compare:    sqlx_.SqlCompareEqual,
		Operator:   sqlx_.SqlOperatorAnd,
	}.NamedSelectStatement()
	if len(likeConds) > 0 {
		query += " AND "
		query += sqlx_.NamedWhereArguments(sqlx_.SqlCompareLike, sqlx_.SqlOperatorAnd, likeConds...)
	}
	if len(orderByCols) > 0 {
		query += fmt.Sprintf(" ORDER BY %s", sqlx_.JoinTableColumns(arg.TableName(), orderByCols...))
	}

	dest, err := arg.GetSqlDatasByQuery(ctx, db, query)

	if err != nil {
		return nil, fmt.Errorf("%w, sql %q", err, query)
	}
	return dest, nil
}

func (arg SqlData) GetSqlDatasWithTx(ctx context.Context, tx *sqlx.Tx, cols []string, conds []string, likeConds []string, orderByCols []string) ([]SqlData, error) {
	query := sqlx_.SimpleStatements{
		TableName:  arg.TableName(),
		Columns:    cols,
		Conditions: conds,
		Compare:    sqlx_.SqlCompareEqual,
		Operator:   sqlx_.SqlOperatorAnd,
	}.NamedSelectStatement()
	if len(likeConds) > 0 {
		query += " AND "
		query += sqlx_.NamedWhereArguments(sqlx_.SqlCompareLike, sqlx_.SqlOperatorAnd, likeConds...)
	}
	if len(orderByCols) > 0 {
		query += fmt.Sprintf(" ORDER BY %s", sqlx_.JoinTableColumns(arg.TableName(), orderByCols...))
	}

	dest, err := arg.GetSqlDatasWithTxByQuery(ctx, tx, query)

	if err != nil {
		return nil, fmt.Errorf("%w, sql %q", err, query)
	}
	return dest, nil
}

func (arg SqlData) GetSqlDatasTemplate(ctx context.Context, db *sqlx.DB, limit, offset int) ([]SqlData, error) {
	query := fmt.Sprintf("SELECT %s FROM %s"+
		//" JOIN %s ON %s"+
		" %s"+ // WHERE
		" %s"+ // GROUP BY
		" %s"+ // ORDER BY
		" %s", // LIMIT
		func() string { // SELECT
			cols := sqlx_.ShrinkEmptyColumns(
				sqlx_.JoinNamedTableColumnsWithAs(arg.TableName(),
					arg.ColumnId(),
					arg.ColumnCreatedAt(),
					arg.ColumnUpdatedAt(),
					arg.ColumnIsDeleted(),
					arg.ColumnDeletedAt(),
					arg.ColumnVersion(),
				))

			if len(cols) == 0 {
				return "*"
			}
			return strings.Join(cols, " , ")
		}(), // WHERE
		arg.TableName(), // FROM
		// other table's name',      // JOIN
		func() string { // WHERE
			cols := sqlx_.ShrinkEmptyColumns(
				// =
				sqlx_.JoinNamedTableCondition(sqlx_.SqlCompareEqual, sqlx_.SqlOperatorAnd,
					arg.TableName(),
					arg.ColumnId(),
					arg.ColumnCreatedAt(),
					arg.ColumnUpdatedAt(),
					arg.ColumnIsDeleted(),
					arg.ColumnDeletedAt(),
					arg.ColumnVersion(),
					//arg.NonzeroColumnsIn(arg.Columns()...)...,
					//arg.NonzeroColumns()...,
				),
				// <>
				sqlx_.JoinNamedTableCondition(sqlx_.SqlCompareNotEqual, sqlx_.SqlOperatorAnd,
					arg.TableName()),
				// LIKE
				sqlx_.JoinNamedTableCondition(sqlx_.SqlCompareLike, sqlx_.SqlOperatorAnd,
					arg.TableName()),
			)

			if len(cols) == 0 {
				return ""
			}

			return "WHERE " + strings.Join(cols, " "+sqlx_.SqlOperatorAnd.String()+" ")
		}(), // WHERE
		func() string { // GROUP BY
			cols := sqlx_.ShrinkEmptyColumns(
				sqlx_.JoinNamedTableColumnsWithAs(arg.TableName()))

			if len(cols) == 0 {
				return ""
			}
			return "GROUP BY " + strings.Join(cols, " , ")
		}(),
		func() string { // ORDER BY
			cols := sqlx_.ShrinkEmptyColumns(
				sqlx_.JoinNamedTableColumnsWithAs(arg.TableName()))

			if len(cols) == 0 {
				return ""
			}
			return "ORDER BY " + strings.Join(cols, " , ")
		}(),
		// LIMIT
		sqlx_.Pagination(limit, offset))

	// Check that invalid preparations fail
	ns, err := db.PrepareNamedContext(ctx, query)
	if err != nil {
		return nil, fmt.Errorf("%w, sql %q", err, query)
	}

	defer ns.Close()

	rows, err := ns.QueryxContext(ctx, arg.MarshalTableMap(nil))
	if err != nil {
		return nil, fmt.Errorf("%w, sql %q", err, query)
	}

	var resps []SqlData
	for rows.Next() {
		row := make(map[string]interface{})
		err := rows.MapScan(row)
		if err != nil {
			return nil, fmt.Errorf("%w, sql %q", err, query)
		}
		for k, v := range row {
			if b, ok := v.([]byte); ok {
				row[k] = string(b)
			}
		}

		resp := SqlData{}
		err = resp.UnmarshalTableMap(row)
		if err != nil {
			return nil, fmt.Errorf("%w, sql %q", err, query)
		}
		resps = append(resps, resp)
	}
	return resps, nil
}

func (arg SqlData) GetSqlDatasTemplateWithTx(ctx context.Context, tx *sqlx.Tx, limit, offset int) ([]SqlData, error) {
	query := fmt.Sprintf("SELECT %s FROM %s"+
		//" JOIN %s ON %s"+
		" %s"+ // WHERE
		" %s"+ // GROUP BY
		" %s"+ // ORDER BY
		" %s", // LIMIT
		func() string { // SELECT
			cols := sqlx_.ShrinkEmptyColumns(
				sqlx_.JoinNamedTableColumnsWithAs(arg.TableName(),
					arg.ColumnId(),
					arg.ColumnCreatedAt(),
					arg.ColumnUpdatedAt(),
					arg.ColumnIsDeleted(),
					arg.ColumnDeletedAt(),
					arg.ColumnVersion(),
				))

			if len(cols) == 0 {
				return "*"
			}
			return strings.Join(cols, " , ")
		}(), // WHERE
		arg.TableName(), // FROM
		// other table's name',      // JOIN
		func() string { // WHERE
			cols := sqlx_.ShrinkEmptyColumns(
				// =
				sqlx_.JoinNamedTableCondition(sqlx_.SqlCompareEqual, sqlx_.SqlOperatorAnd,
					arg.TableName(),
					arg.ColumnId(),
					arg.ColumnCreatedAt(),
					arg.ColumnUpdatedAt(),
					arg.ColumnIsDeleted(),
					arg.ColumnDeletedAt(),
					arg.ColumnVersion(),
					//arg.NonzeroColumnsIn(arg.Columns()...)...,
					//arg.NonzeroColumns()...,
				),
				// <>
				sqlx_.JoinNamedTableCondition(sqlx_.SqlCompareNotEqual, sqlx_.SqlOperatorAnd,
					arg.TableName()),
				// LIKE
				sqlx_.JoinNamedTableCondition(sqlx_.SqlCompareLike, sqlx_.SqlOperatorAnd,
					arg.TableName()),
			)

			if len(cols) == 0 {
				return ""
			}

			return "WHERE " + strings.Join(cols, " "+sqlx_.SqlOperatorAnd.String()+" ")
		}(), // WHERE
		func() string { // GROUP BY
			cols := sqlx_.ShrinkEmptyColumns(
				sqlx_.JoinNamedTableColumnsWithAs(arg.TableName()))

			if len(cols) == 0 {
				return ""
			}
			return "GROUP BY " + strings.Join(cols, " , ")
		}(),
		func() string { // ORDER BY
			cols := sqlx_.ShrinkEmptyColumns(
				sqlx_.JoinNamedTableColumnsWithAs(arg.TableName()))

			if len(cols) == 0 {
				return ""
			}
			return "ORDER BY " + strings.Join(cols, " , ")
		}(),
		// LIMIT
		sqlx_.Pagination(limit, offset))

	// Check that invalid preparations fail
	ns, err := tx.PrepareNamedContext(ctx, query)
	if err != nil {
		return nil, fmt.Errorf("%w, sql %q", err, query)
	}

	defer ns.Close()

	rows, err := ns.QueryxContext(ctx, arg.MarshalTableMap(nil))
	if err != nil {
		return nil, fmt.Errorf("%w, sql %q", err, query)
	}

	var resps []SqlData
	for rows.Next() {
		row := make(map[string]interface{})
		err := rows.MapScan(row)
		if err != nil {
			return nil, fmt.Errorf("%w, sql %q", err, query)
		}
		for k, v := range row {
			if b, ok := v.([]byte); ok {
				row[k] = string(b)
			}
		}

		resp := SqlData{}
		err = resp.UnmarshalTableMap(row)
		if err != nil {
			return nil, fmt.Errorf("%w, sql %q", err, query)
		}
		resps = append(resps, resp)
	}
	return resps, nil
}
