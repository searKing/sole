// Copyright 2023 The searKing Author. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package option

import (
	"fmt"
	"go/ast"
	"strings"

	slices_ "github.com/searKing/golang/go/exp/slices"
	reflect_ "github.com/searKing/golang/go/reflect"
	strings_ "github.com/searKing/golang/go/strings"
)

type TmplOptionRender struct {
	// Print the header and package clause.
	GoOptionToolName       string
	GoOptionToolArgs       []string
	GoOptionToolArgsJoined string

	PackageName string
	ImportPaths []string
	ValDecls    []string

	TargetTypeName               string // type name of target type
	TargetTypeImport             string // import path of target type
	TargetTypeGenericDeclaration string // the Generic type of the struct type
	TargetTypeGenericParams      string // the Generic params of the struct type
	TrimmedTypeName              string // trimmed type name of target type

	FormatTypeName string        // The format FieldName of the struct type.
	Fields         []StructField // fields if target type is struct

	OptionInterfaceName string // option interface name of target type
	OptionStructName    string // option struct name of target type

	ApplyOptionsAsMemberFunction bool // ApplyOptions can be registered as OptionType's member function
	WithTargetTypeNameAsPrefix   bool // WithXXX() can be generated as {{OptionType}}WithXXX()
}

// Struct represents a declared constant.
type Struct struct {
	FileImports                  []string // The import path of the file contains the struct
	StructTypeImport             string   // The import path of StructTypeName.
	StructTypeName               string   // The StructTypeName of the struct.
	StructTypeGenericDeclaration string   // the Generic type of the struct type
	StructTypeGenericTypeParams  string   // the Generic params of the struct type
	trimmedStructTypeName        string   // The trimmed StructTypeName of the struct.
	IsStruct                     bool
	Fields                       []StructField
}

type StructField struct {
	FieldName        string                // The FieldName of the struct field.
	FieldType        string                // The FieldType of the struct field.
	FieldDocComment  *ast.CommentGroup     // The doc comment of the struct field.
	FieldLineComment *ast.CommentGroup     // The line comment of the struct field.
	OptionTag        reflect_.SubStructTag // The OptionTag of the struct field.
	FieldIsMap       bool                  // The FieldType of the struct field is a map.
	FieldSliceElt    string                // slice elt type name, for ...type_of_slice_element

	FormatFieldName     string   // The format FieldName of the struct field.
	FormatFieldComments []string // The format comment of the struct field.
}

func (t *TmplOptionRender) Complete() {
	t.GoOptionToolArgsJoined = strings.Join(t.GoOptionToolArgs, " ")
	t.ApplyOptionsAsMemberFunction = strings.TrimSpace(t.TargetTypeImport) == ""

	t.OptionInterfaceName = strings_.UpperCamelCaseSlice("option")
	t.OptionStructName = strings_.UpperCamelCaseSlice("config")
	if !*trim && t.TrimmedTypeName != "" {
		t.OptionInterfaceName = strings_.UpperCamelCaseSlice(t.TrimmedTypeName, "option")
		t.OptionStructName = strings_.UpperCamelCaseSlice(t.TrimmedTypeName, "config")
	}

	importPath := strings.TrimSpace(t.TargetTypeImport)
	if importPath != "" {
		t.ImportPaths = append(t.ImportPaths, fmt.Sprintf("%q", importPath))
	}
	t.ImportPaths = slices_.Filter(t.ImportPaths)

	_, defaultValDecl := createValAndNameDecl(t.TargetTypeName)
	if defaultValDecl != "" {
		t.ValDecls = append(t.ValDecls, defaultValDecl)
	}

	t.FormatTypeName = strings_.ToUpperLeading(t.TargetTypeName)

	for i, field := range t.Fields {
		t.Fields[i].FormatFieldName = strings_.UpperCamelCaseSlice(strings_.ValueOrDefault(field.OptionTag.Name, field.FieldName))
		if !field.OptionTag.HasOption(TagOptionFlagShort) {
			t.Fields[i].FormatFieldName = strings_.ToUpperLeading(t.TrimmedTypeName) + t.Fields[i].FormatFieldName
		}
		if field.FieldDocComment != nil {
			for _, c := range field.FieldDocComment.List {
				t.Fields[i].FormatFieldComments = append(t.Fields[i].FormatFieldComments, c.Text)
			}
		}
		if field.FieldLineComment != nil {
			for _, c := range field.FieldLineComment.List {
				t.Fields[i].FormatFieldComments = append(t.Fields[i].FormatFieldComments, c.Text)
			}
		}
	}
}

const tmplOption = `// Code generated by "{{.GoOptionToolName}} {{.GoOptionToolArgsJoined}}"; DO NOT EDIT.
// Install {{.GoOptionToolName}} by "go get install github.com/searKing/golang/tools/{{.GoOptionToolName}}"
{{ $package_scope := . }}

package {{.PackageName}} 

{{range $path := .ImportPaths}} 
import {{$path}} 
{{end}}

// A {{.OptionInterfaceName}} sets options.
type {{.OptionInterfaceName}}{{.TargetTypeGenericDeclaration}} interface {
	apply(*{{.TargetTypeName}}{{.TargetTypeGenericParams}})
}

// Empty{{.OptionInterfaceName}} does not alter the configuration. It can be embedded
// in another structure to build custom options.
//
// This API is EXPERIMENTAL.
type Empty{{.OptionInterfaceName}}{{.TargetTypeGenericDeclaration}} struct{}

func (Empty{{.OptionInterfaceName}}{{.TargetTypeGenericParams}}) apply(*{{.TargetTypeName}}{{.TargetTypeGenericParams}}) {}

// {{.OptionInterfaceName}}Func wraps a function that modifies {{.TargetTypeName}}{{.TargetTypeGenericParams}} into an
// implementation of the {{.OptionInterfaceName}}{{.TargetTypeGenericDeclaration}} interface.
type {{.OptionInterfaceName}}Func{{.TargetTypeGenericDeclaration}} func(*{{.TargetTypeName}}{{.TargetTypeGenericParams}})

func (f {{.OptionInterfaceName}}Func{{.TargetTypeGenericParams}}) apply(do *{{.TargetTypeName}}{{.TargetTypeGenericParams}}) {
	f(do)
}

{{- if .ApplyOptionsAsMemberFunction }}
// ApplyOptions call apply() for all options one by one
func (o *{{.TargetTypeName}}{{.TargetTypeGenericParams}}) ApplyOptions(options ...{{.OptionInterfaceName}}{{.TargetTypeGenericParams}}) *{{.TargetTypeName}}{{.TargetTypeGenericParams}} {
	for _, opt := range options {
		if opt == nil {
			continue
		}
		opt.apply(o)
	}
	return o
}
{{- else}}
// ApplyOptions call apply() for all options one by one
func ApplyOptions{{.TargetTypeGenericDeclaration}}(o *{{.TargetTypeName}}{{.TargetTypeGenericParams}}, options ...{{.OptionInterfaceName}}{{.TargetTypeGenericParams}}) *{{.TargetTypeName}}{{.TargetTypeGenericParams}} {
	for _, opt := range options {
		if opt == nil {
			continue
		}
		opt.apply(o)
	}
	return o
}
{{- end}}

{{- if .TargetTypeName | IsExported }}
// With{{.FormatTypeName}} sets {{.TargetTypeName}}.
func With{{.FormatTypeName}}{{.TargetTypeGenericDeclaration}}(v {{.TargetTypeName}}{{.TargetTypeGenericParams}}) {{.OptionInterfaceName}}{{.TargetTypeGenericParams}} {
	return {{.OptionInterfaceName}}Func{{$package_scope.TargetTypeGenericParams}} (func( o *{{.TargetTypeName}}{{.TargetTypeGenericParams}}) {
		*o = v
	})
}
{{- else}}
// with{{.FormatTypeName}} sets {{.TargetTypeName}}.
func with{{.FormatTypeName}}{{.TargetTypeGenericDeclaration}}(v {{.TargetTypeName}}{{.TargetTypeGenericParams}}) {{.OptionInterfaceName}}{{.TargetTypeGenericParams}} {
	return {{.OptionInterfaceName}}Func{{$package_scope.TargetTypeGenericParams}} (func( o *{{.TargetTypeName}}{{.TargetTypeGenericParams}}) {
		*o = v
	})
}
{{- end}}

{{- if not .Fields }}
// sample code for option, default for nothing to change
func _{{.OptionInterfaceName}}WithDefault{{.TargetTypeGenericDeclaration}}() {{.OptionInterfaceName}}{{.TargetTypeGenericParams}} {
	return {{.OptionInterfaceName}}Func{{$package_scope.TargetTypeGenericParams}} (func( *{{.TargetTypeName}}{{.TargetTypeGenericParams}}) {
		// nothing to change
	})
}
{{- end}}
{{- range .Fields}}
{{- if $package_scope.WithTargetTypeNameAsPrefix }} in {{$package_scope.TargetTypeName}}{{$package_scope.TargetTypeGenericParams}}.
// {{$package_scope.OptionInterfaceName}}With{{.FieldName}} sets {{.FieldName}}.
func {{$package_scope.OptionInterfaceName}}With{{.FieldName}}{{$package_scope.TargetTypeGenericDeclaration}}(v {{.FieldType}}) {{$package_scope.OptionInterfaceName}} {
	return {{$package_scope.OptionInterfaceName}}{{$package_scope.TargetTypeGenericParams}} Func{{$package_scope.TargetTypeGenericParams}} (func( o *{{$package_scope.TargetTypeName}}{{$package_scope.TargetTypeGenericParams}} {
		o.{{.FieldName}} = v
	})
}
{{- else}}
{{- if .FieldSliceElt }}
// With{{.FormatFieldName}} appends {{.FieldName}} in {{$package_scope.TargetTypeName}}{{$package_scope.TargetTypeGenericParams}}.
{{- range .FormatFieldComments}}
{{.}}
{{- end}}
func With{{.FormatFieldName}}{{$package_scope.TargetTypeGenericDeclaration}}(v ...{{.FieldSliceElt}}) {{$package_scope.OptionInterfaceName}}{{$package_scope.TargetTypeGenericParams}} {
	return {{$package_scope.OptionInterfaceName}}Func{{$package_scope.TargetTypeGenericParams}} (func( o *{{$package_scope.TargetTypeName}}{{$package_scope.TargetTypeGenericParams}}) {
		o.{{.FieldName}} = append(o.{{.FieldName}}, v...)
	})
}
// With{{.FormatFieldName}}Replace sets {{.FieldName}} in {{$package_scope.TargetTypeName}}{{$package_scope.TargetTypeGenericParams}}.
{{- range .FormatFieldComments}}
{{.}}
{{- end}}
func With{{.FormatFieldName}}Replace{{$package_scope.TargetTypeGenericDeclaration}}(v ...{{.FieldSliceElt}}) {{$package_scope.OptionInterfaceName}}{{$package_scope.TargetTypeGenericParams}} {
	return {{$package_scope.OptionInterfaceName}}Func{{$package_scope.TargetTypeGenericParams}} (func( o *{{$package_scope.TargetTypeName}}{{$package_scope.TargetTypeGenericParams}}) {
		o.{{.FieldName}} = v
	})
}
{{- else if .FieldIsMap}}
// With{{.FormatFieldName}} appends {{.FieldName}} in {{$package_scope.TargetTypeName}}{{$package_scope.TargetTypeGenericParams}}.
{{- range .FormatFieldComments}}
{{.}}
{{- end}}
func With{{.FormatFieldName}}{{$package_scope.TargetTypeGenericDeclaration}}(m {{.FieldType}}) {{$package_scope.OptionInterfaceName}}{{$package_scope.TargetTypeGenericParams}} {
	return {{$package_scope.OptionInterfaceName}}Func{{$package_scope.TargetTypeGenericParams}} (func( o *{{$package_scope.TargetTypeName}}{{$package_scope.TargetTypeGenericParams}}) {
		if o.{{.FieldName}} == nil {
			o.{{.FieldName}} = m
			return
		}
		for k,v := range m {
			o.{{.FieldName}}[k] = v
		}
	})
}
// With{{.FormatFieldName}}Replace sets {{.FieldName}} in {{$package_scope.TargetTypeName}}{{$package_scope.TargetTypeGenericParams}}.
{{- range .FormatFieldComments}}
{{.}}
{{- end}}
func With{{.FormatFieldName}}Replace{{$package_scope.TargetTypeGenericDeclaration}}(v {{.FieldType}}) {{$package_scope.OptionInterfaceName}}{{$package_scope.TargetTypeGenericParams}} {
	return {{$package_scope.OptionInterfaceName}}Func{{$package_scope.TargetTypeGenericParams}} (func( o *{{$package_scope.TargetTypeName}}{{$package_scope.TargetTypeGenericParams}}) {
		o.{{.FieldName}} = v
	})
}
{{- else}}
// With{{.FormatFieldName}} sets {{.FieldName}} in {{$package_scope.TargetTypeName}}{{$package_scope.TargetTypeGenericParams}}.
{{- range .FormatFieldComments}}
{{.}}
{{- end}}
func With{{.FormatFieldName}}{{$package_scope.TargetTypeGenericDeclaration}}(v {{.FieldType}}) {{$package_scope.OptionInterfaceName}}{{$package_scope.TargetTypeGenericParams}} {
	return {{$package_scope.OptionInterfaceName}}Func{{$package_scope.TargetTypeGenericParams}} (func( o *{{$package_scope.TargetTypeName}}{{$package_scope.TargetTypeGenericParams}}) {
		o.{{.FieldName}} = v
	})
}
{{- end}}
{{- end}}
{{- end}}
`
