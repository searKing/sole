// Copyright 2021 The searKing Author. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Code generated by "go-option -type=Config"; DO NOT EDIT.

package provider

var _default_Config_value = func() (val Config) { return }()

// A ConfigOption sets options.
type ConfigOption interface {
	apply(*Config)
}

// EmptyConfigOption does not alter the configuration. It can be embedded
// in another structure to build custom options.
//
// This API is EXPERIMENTAL.
type EmptyConfigOption struct{}

func (EmptyConfigOption) apply(*Config) {}

// ConfigOptionFunc wraps a function that modifies Config into an
// implementation of the ConfigOption interface.
type ConfigOptionFunc func(*Config)

func (f ConfigOptionFunc) apply(do *Config) {
	f(do)
}

// sample code for option, default for nothing to change
func _ConfigOptionWithDefault() ConfigOption {
	return ConfigOptionFunc(func(*Config) {
		// nothing to change
	})
}
func (o *Config) ApplyOptions(options ...ConfigOption) *Config {
	for _, opt := range options {
		if opt == nil {
			continue
		}
		opt.apply(o)
	}
	return o
}

type completedConfig struct {
	*Config
}

type CompletedConfig struct {
	// Embed a private pointer that cannot be instantiated outside of this package.
	*completedConfig
}

// recommend to implement codes below
// Code borrowed from https://github.com/kubernetes/kubernetes

//// Complete fills in any fields not set that are required to have valid data and can be derived
//// from other fields. If you're going to ApplyOptions, do that first. It's mutating the receiver.
//// ApplyOptions is called inside.
// func (o *Config) Complete(options ...ConfigOption) CompletedConfig {
//  o.ApplyOptions(options...)
//  // Add custom codes here
//  return CompletedConfig{&completedConfig{o}}
// }

//// New creates a new server which logically combines the handling chain with the passed server.
//// name is used to differentiate for logging. The handler chain in particular can be difficult as it starts delgating.
//// New usually called after Complete
//func (c completedConfig) New(name string) (*Config, error) {
//  // Add custom codes here
//	return nil, fmt.Errorf("not implemented")
//}

//// Apply set options and something else as global init, act likes New but without Config's instance
//// Apply usually called after Complete
//func (c completedConfig) Apply() error {
//  // Add custom codes here
//	return fmt.Errorf("not implemented")
//}
