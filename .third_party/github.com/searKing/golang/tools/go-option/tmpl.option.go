package main

import (
	"go/ast"
	"strings"

	reflect_ "github.com/searKing/golang/go/reflect"
	strings_ "github.com/searKing/golang/go/strings"
)

type TmplOptionRender struct {
	// Print the header and package clause.
	GoOptionToolName       string
	GoOptionToolArgs       []string
	GoOptionToolArgsJoined string

	PackageName string
	ImportPaths []string
	ValDecls    []string

	TargetTypeName   string        // type name of target type
	TargetTypeImport string        // import path of target type
	TrimmedTypeName  string        // trimmed type name of target type
	Fields           []StructField // fields if target type is struct

	OptionInterfaceName string // option interface name of target type
	OptionStructName    string // option struct name of target type

	ApplyOptionsAsMemberFunction bool // ApplyOptions can be registered as OptionType's member function
	WithTargetTypeNameAsPrefix   bool // WithXXX() can be generated as {{OptionType}}WithXXX()
}

// Struct represents a declared constant.
type Struct struct {
	StructTypeImport      string // The import path of StructTypeName.
	StructTypeName        string // The StructTypeName of the struct.
	trimmedStructTypeName string // The trimmed StructTypeName of the struct.
	IsStruct              bool
	Fields                []StructField
}

type StructField struct {
	FieldName        string                // The FieldName of the struct field.
	FieldType        string                // The FieldType of the struct field.
	FieldDocComment  *ast.CommentGroup     // The doc comment of the struct field.
	FieldLineComment *ast.CommentGroup     // The line comment of the struct field.
	OptionTag        reflect_.SubStructTag // The OptionTag of the struct field.
	FieldIsSlice     bool                  // The FieldType of the struct field is a slice.
	FieldSliceElt    string                // slice elt type name
	FieldIsMap       bool                  // The FieldType of the struct field is a map.

	FormatFieldName     string   // The format FieldName of the struct field.
	FormatFieldComments []string // The format comment of the struct field.
}

func (t *TmplOptionRender) Complete() {
	t.GoOptionToolArgsJoined = strings.Join(t.GoOptionToolArgs, " ")
	t.ApplyOptionsAsMemberFunction = strings.TrimSpace(t.TargetTypeImport) == ""

	t.OptionInterfaceName = strings_.UpperCamelCaseSlice("option")
	t.OptionStructName = strings_.UpperCamelCaseSlice("config")
	if !*trim && t.TrimmedTypeName != "" {
		t.OptionInterfaceName = strings_.UpperCamelCaseSlice(t.TrimmedTypeName, "option")
		t.OptionStructName = strings_.UpperCamelCaseSlice(t.TrimmedTypeName, "config")
	}

	importPath := strings.TrimSpace(t.TargetTypeImport)
	if importPath != "" {
		t.ImportPaths = append(t.ImportPaths, importPath)
	}

	_, defaultValDecl := createValAndNameDecl(t.TargetTypeName)
	if defaultValDecl != "" {
		t.ValDecls = append(t.ValDecls, defaultValDecl)
	}

	for i, field := range t.Fields {
		t.Fields[i].FormatFieldName = strings_.UpperCamelCaseSlice(strings_.ValueOrDefault(field.OptionTag.Name, field.FieldName))
		if !field.OptionTag.HasOption(TagOptionFlagShort) {
			t.Fields[i].FormatFieldName = t.TrimmedTypeName + t.Fields[i].FormatFieldName
		}
		if field.FieldDocComment != nil {
			for _, c := range field.FieldDocComment.List {
				t.Fields[i].FormatFieldComments = append(t.Fields[i].FormatFieldComments, c.Text)
			}
		}
		if field.FieldLineComment != nil {
			for _, c := range field.FieldLineComment.List {
				t.Fields[i].FormatFieldComments = append(t.Fields[i].FormatFieldComments, c.Text)
			}
		}
	}
}

const tmplOption = `// Code generated by "{{.GoOptionToolName}} {{.GoOptionToolArgsJoined}}"; DO NOT EDIT.
// Install {{.GoOptionToolName}} by "go get -u github.com/searKing/golang/tools/{{.GoOptionToolName}}"
{{ $package_scope := . }}

package {{.PackageName}} 

{{range $path := .ImportPaths}} import "{{$path}}" {{end}}

// A {{.OptionInterfaceName}} sets options.
type {{.OptionInterfaceName}} interface {
	apply(*{{.TargetTypeName}})
}

// Empty{{.OptionInterfaceName}} does not alter the configuration. It can be embedded
// in another structure to build custom options.
//
// This API is EXPERIMENTAL.
type Empty{{.OptionInterfaceName}} struct{}

func (Empty{{.OptionInterfaceName}}) apply(*{{.TargetTypeName}}) {}

// {{.OptionInterfaceName}}Func wraps a function that modifies {{.TargetTypeName}} into an
// implementation of the {{.OptionInterfaceName}} interface.
type {{.OptionInterfaceName}}Func func(*{{.TargetTypeName}})

func (f {{.OptionInterfaceName}}Func) apply(do *{{.TargetTypeName}}) {
	f(do)
}

{{- if .ApplyOptionsAsMemberFunction }}
func (o *{{.TargetTypeName}}) ApplyOptions(options ...{{.OptionInterfaceName}}) *{{.TargetTypeName}} {
	for _, opt := range options {
		if opt == nil {
			continue
		}
		opt.apply(o)
	}
	return o
}
{{- else}}
func ApplyOptions(o *{{.TargetTypeName}}, options ...{{.OptionInterfaceName}}) *{{.TargetTypeName}} {
	for _, opt := range options {
		if opt == nil {
			continue
		}
		opt.apply(o)
	}
	return o
}
{{- end}}

{{- if not .Fields }}
// sample code for option, default for nothing to change
func _{{.OptionInterfaceName}}WithDefault() {{.OptionInterfaceName}} {
	return {{.OptionInterfaceName}}Func(func( *{{.TargetTypeName}}) {
		// nothing to change
	})
}
{{- end}}
{{- range .Fields}}
{{- if $package_scope.WithTargetTypeNameAsPrefix }} in {{$package_scope.TargetTypeName}}.
// {{$package_scope.OptionInterfaceName}}With{{.FieldName}} sets {{.FieldName}}.
func {{$package_scope.OptionInterfaceName}}With{{.FieldName}}(v {{.FieldType}}) {{$package_scope.OptionInterfaceName}} {
	return {{$package_scope.OptionInterfaceName}}Func(func( o *{{$package_scope.TargetTypeName}}) {
		o.{{.FieldName}} = v
	})
}
{{- else}}
{{- if .FieldIsSlice }}
// With{{.FormatFieldName}} appends {{.FieldName}} in {{$package_scope.TargetTypeName}}.
{{- range .FormatFieldComments}}
{{.}}
{{- end}}
func With{{.FormatFieldName}}(v ...{{.FieldSliceElt}}) {{$package_scope.OptionInterfaceName}} {
	return {{$package_scope.OptionInterfaceName}}Func(func( o *{{$package_scope.TargetTypeName}}) {
		o.{{.FieldName}} = append(o.{{.FieldName}}, v...)
	})
}
// With{{.FormatFieldName}}Replace sets {{.FieldName}} in {{$package_scope.TargetTypeName}}.
{{- range .FormatFieldComments}}
{{.}}
{{- end}}
func With{{.FormatFieldName}}Replace(v ...{{.FieldSliceElt}}) {{$package_scope.OptionInterfaceName}} {
	return {{$package_scope.OptionInterfaceName}}Func(func( o *{{$package_scope.TargetTypeName}}) {
		o.{{.FieldName}} = v
	})
}
{{- else if .FieldIsMap}}
// With{{.FormatFieldName}} appends {{.FieldName}} in {{$package_scope.TargetTypeName}}.
{{- range .FormatFieldComments}}
{{.}}
{{- end}}
func With{{.FormatFieldName}}(m {{.FieldType}}) {{$package_scope.OptionInterfaceName}} {
	return {{$package_scope.OptionInterfaceName}}Func(func( o *{{$package_scope.TargetTypeName}}) {
		if o.{{.FieldName}} == nil {
			o.{{.FieldName}} = m
			return
		}
		for k,v := range m {
			o.{{.FieldName}}[k] = v
		}
	})
}
// With{{.FormatFieldName}}Replace sets {{.FieldName}} in {{$package_scope.TargetTypeName}}.
{{- range .FormatFieldComments}}
{{.}}
{{- end}}
func With{{.FormatFieldName}}Replace(v {{.FieldType}}) {{$package_scope.OptionInterfaceName}} {
	return {{$package_scope.OptionInterfaceName}}Func(func( o *{{$package_scope.TargetTypeName}}) {
		o.{{.FieldName}} = v
	})
}
{{- else}}
// With{{.FormatFieldName}} sets {{.FieldName}} in {{$package_scope.TargetTypeName}}.
{{- range .FormatFieldComments}}
{{.}}
{{- end}}
func With{{.FormatFieldName}}(v {{.FieldType}}) {{$package_scope.OptionInterfaceName}} {
	return {{$package_scope.OptionInterfaceName}}Func(func( o *{{$package_scope.TargetTypeName}}) {
		o.{{.FieldName}} = v
	})
}
{{- end}}
{{- end}}
{{- end}}
`
