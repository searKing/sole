package main

import (
	"strings"

	strings_ "github.com/searKing/golang/go/strings"
)

type TmplOptionRender struct {
	// Print the header and package clause.
	GoOptionToolName       string
	GoOptionToolArgs       []string
	GoOptionToolArgsJoined string

	PackageName string
	ImportPaths []string
	ValDecls    []string

	TargetTypeName   string // type name of target type
	TargetTypeImport string // import path of target type
	TrimmedTypeName  string // trimmed type name of target type

	OptionInterfaceName string // option interface name of target type
	OptionStructName    string // option struct name of target type

	ApplyOptionsAsMemberFunction bool // ApplyOptions can be registered as OptionType's member function
}

func (t *TmplOptionRender) Complete() {
	t.GoOptionToolArgsJoined = strings.Join(t.GoOptionToolArgs, " ")
	t.ApplyOptionsAsMemberFunction = strings.TrimSpace(t.TargetTypeImport) == ""

	t.OptionInterfaceName = strings_.UpperCamelCaseSlice("option")
	t.OptionStructName = strings_.UpperCamelCaseSlice("config")
	if !*trim && t.TrimmedTypeName != "" {
		t.OptionInterfaceName = strings_.UpperCamelCaseSlice(t.TrimmedTypeName, "option")
		t.OptionStructName = strings_.UpperCamelCaseSlice(t.TrimmedTypeName, "config")
	}

	importPath := strings.TrimSpace(t.TargetTypeImport)
	if importPath != "" {
		t.ImportPaths = append(t.ImportPaths, importPath)
	}

	_, defaultValDecl := createValAndNameDecl(t.TargetTypeName)
	if defaultValDecl != "" {
		t.ValDecls = append(t.ValDecls, defaultValDecl)
	}
}

const tmplOption = `// Code generated by "{{.GoOptionToolName}} {{.GoOptionToolArgsJoined}}"; DO NOT EDIT.
// Install {{.GoOptionToolName}} by "go get -u github.com/searKing/golang/tools/{{.GoOptionToolName}}"

package {{.PackageName}} 

{{range $path := .ImportPaths}} import "{{$path}}" {{end}}

// A {{.OptionInterfaceName}} sets options.
type {{.OptionInterfaceName}} interface {
	apply(*{{.TargetTypeName}})
}

// Empty{{.OptionInterfaceName}} does not alter the configuration. It can be embedded
// in another structure to build custom options.
//
// This API is EXPERIMENTAL.
type Empty{{.OptionInterfaceName}} struct{}

func (Empty{{.OptionInterfaceName}}) apply(*{{.TargetTypeName}}) {}

// {{.OptionInterfaceName}}Func wraps a function that modifies {{.TargetTypeName}} into an
// implementation of the {{.OptionInterfaceName}} interface.
type {{.OptionInterfaceName}}Func func(*{{.TargetTypeName}})

func (f {{.OptionInterfaceName}}Func) apply(do *{{.TargetTypeName}}) {
	f(do)
}

// sample code for option, default for nothing to change
func _{{.OptionInterfaceName}}WithDefault() {{.OptionInterfaceName}} {
	return {{.OptionInterfaceName}}Func(func( *{{.TargetTypeName}}) {
		// nothing to change
	})
}

{{- if .ApplyOptionsAsMemberFunction }}
func (o *{{.TargetTypeName}}) ApplyOptions(options ...{{.OptionInterfaceName}}) *{{.TargetTypeName}} {
	for _, opt := range options {
		if opt == nil {
			continue
		}
		opt.apply(o)
	}
	return o
}
{{- else}}
func ApplyOptions(o *{{.TargetTypeName}}, options ...{{.OptionInterfaceName}}) *{{.TargetTypeName}} {
	for _, opt := range options {
		if opt == nil {
			continue
		}
		opt.apply(o)
	}
	return o
}
{{- end}}
`
