package main

import (
	strings_ "github.com/searKing/golang/go/strings"
	"strings"
)

type TmplConfigRender struct {
	// Print the header and package clause.
	GoOptionToolName       string
	GoOptionToolArgs       []string
	GoOptionToolArgsJoined string

	PackageName string
	ImportPaths []string
	ValDecls    []string

	TargetTypeName   string // type name of target type
	TargetTypeImport string // import path of target type
	TrimmedTypeName  string // trimmed type name of target type

	OptionInterfaceName string // option interface name of target type
	OptionStructName    string // option struct name of target type

	ApplyOptionsAsMemberFunction bool // ApplyOptions can be registered as OptionType's member function
}

func (t *TmplConfigRender) Complete() {
	t.GoOptionToolArgsJoined = strings.Join(t.GoOptionToolArgs, " ")
	t.ApplyOptionsAsMemberFunction = strings.TrimSpace(t.TargetTypeImport) == ""

	t.OptionInterfaceName = strings_.UpperCamelCaseSlice("option")
	t.OptionStructName = strings_.UpperCamelCaseSlice("config")
	if !*trim && t.TrimmedTypeName != "" {
		t.OptionInterfaceName = strings_.UpperCamelCaseSlice(t.TrimmedTypeName, "option")
		t.OptionStructName = strings_.UpperCamelCaseSlice(t.TrimmedTypeName, "config")
	}

	importPath := strings.TrimSpace(t.TargetTypeImport)
	if importPath != "" {
		t.ImportPaths = append(t.ImportPaths, importPath)
	}

	_, defaultValDecl := createValAndNameDecl(t.TargetTypeName)
	if defaultValDecl != "" {
		t.ValDecls = append(t.ValDecls, defaultValDecl)
	}
}

const tmplConfig = `// Code generated by "{{.GoOptionToolName}} {{.GoOptionToolArgsJoined}}"; EDIT IT ANYWAY.
package {{.PackageName}} 

{{range $path := .ImportPaths}} import "{{$path}}" {{end}}

// Code borrowed from https://github.com/kubernetes/kubernetes
// call chains: NewConfig -> Complete -> [Validate] -> New|Apply
type {{.OptionStructName}} struct {
	// TODO Add config fields here
}

{{- if .ApplyOptionsAsMemberFunction }}
type completed{{.OptionStructName}} struct {
	*{{.OptionStructName}}

	//===========================================================================
	// values below here are filled in during completion
	//===========================================================================
}

type Completed{{.OptionStructName}} struct {
	// Embed a private pointer that cannot be instantiated outside of this package.
	*completed{{.OptionStructName}}
}

// NewConfig returns a Config struct with the default values
func New{{.OptionStructName}}() *{{.OptionStructName}} {
	// TODO Add default configs here
	return &{{.OptionStructName}}{}
}

// Complete fills in any fields not set that are required to have valid data and can be derived
// from other fields. If you're going to ApplyOptions, do that first. It's mutating the receiver.
func (o *{{.OptionStructName}}) Complete() Completed{{.OptionStructName}} {
	// TODO Add custom codes here
	return Completed{{.OptionStructName}}{&completed{{.OptionStructName}}{o}}
}

// Validate checks {{.OptionStructName}} and return a slice of found errs.
func (o *{{.OptionStructName}}) Validate() []error {
	var errs []error
	// TODO Add custom validate codes here
	return errs
}

// New creates a new server which logically combines the handling chain with the passed server.
// The handler chain in particular can be difficult as it starts delgating.
// New usually called after Complete
func (c completed{{.OptionStructName}}) New() (*{{.TargetTypeName}}, error) {
	// TODO Add custom codes here
	return nil, fmt.Errorf("not implemented")
}

// Apply set options and something else as global init, act likes New but without {{.OptionStructName}}'s instance
// Apply usually called after Complete
func (c completed{{.OptionStructName}}) Apply() error {
	// TODO Add custom codes here
	return fmt.Errorf("not implemented")
}

{{- else}}
func Complete(o *{{.OptionStructName}}, options ...{{.OptionInterfaceName}}) Completed{{.OptionStructName}} {
	ApplyOptions(o, options...)
	// TODO Add custom codes here
	return Completed{{.OptionStructName}}{&completed{{.OptionStructName}}{o}}
}
{{- end}}
`
